"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pg-pool@3.11.0_pg@8.18.0";
exports.ids = ["vendor-chunks/pg-pool@3.11.0_pg@8.18.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/pg-pool@3.11.0_pg@8.18.0/node_modules/pg-pool/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/pg-pool@3.11.0_pg@8.18.0/node_modules/pg-pool/index.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter)\n\nconst NOOP = function () {}\n\nconst removeWhere = (list, predicate) => {\n  const i = list.findIndex(predicate)\n\n  return i === -1 ? undefined : list.splice(i, 1)[0]\n}\n\nclass IdleItem {\n  constructor(client, idleListener, timeoutId) {\n    this.client = client\n    this.idleListener = idleListener\n    this.timeoutId = timeoutId\n  }\n}\n\nclass PendingItem {\n  constructor(callback) {\n    this.callback = callback\n  }\n}\n\nfunction throwOnDoubleRelease() {\n  throw new Error('Release called on client which has already been released to the pool.')\n}\n\nfunction promisify(Promise, callback) {\n  if (callback) {\n    return { callback: callback, result: undefined }\n  }\n  let rej\n  let res\n  const cb = function (err, client) {\n    err ? rej(err) : res(client)\n  }\n  const result = new Promise(function (resolve, reject) {\n    res = resolve\n    rej = reject\n  }).catch((err) => {\n    // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the\n    // application that created the query\n    Error.captureStackTrace(err)\n    throw err\n  })\n  return { callback: cb, result: result }\n}\n\nfunction makeIdleListener(pool, client) {\n  return function idleListener(err) {\n    err.client = client\n\n    client.removeListener('error', idleListener)\n    client.on('error', () => {\n      pool.log('additional client error after disconnection due to error', err)\n    })\n    pool._remove(client)\n    // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n    pool.emit('error', err, client)\n  }\n}\n\nclass Pool extends EventEmitter {\n  constructor(options, Client) {\n    super()\n    this.options = Object.assign({}, options)\n\n    if (options != null && 'password' in options) {\n      // \"hiding\" the password so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options, 'password', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: options.password,\n      })\n    }\n    if (options != null && options.ssl && options.ssl.key) {\n      // \"hiding\" the ssl->key so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options.ssl, 'key', {\n        enumerable: false,\n      })\n    }\n\n    this.options.max = this.options.max || this.options.poolSize || 10\n    this.options.min = this.options.min || 0\n    this.options.maxUses = this.options.maxUses || Infinity\n    this.options.allowExitOnIdle = this.options.allowExitOnIdle || false\n    this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0\n    this.log = this.options.log || function () {}\n    this.Client = this.options.Client || Client || (__webpack_require__(/*! pg */ \"(rsc)/./node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/index.js\").Client)\n    this.Promise = this.options.Promise || global.Promise\n\n    if (typeof this.options.idleTimeoutMillis === 'undefined') {\n      this.options.idleTimeoutMillis = 10000\n    }\n\n    this._clients = []\n    this._idle = []\n    this._expired = new WeakSet()\n    this._pendingQueue = []\n    this._endCallback = undefined\n    this.ending = false\n    this.ended = false\n  }\n\n  _isFull() {\n    return this._clients.length >= this.options.max\n  }\n\n  _isAboveMin() {\n    return this._clients.length > this.options.min\n  }\n\n  _pulseQueue() {\n    this.log('pulse queue')\n    if (this.ended) {\n      this.log('pulse queue ended')\n      return\n    }\n    if (this.ending) {\n      this.log('pulse queue on ending')\n      if (this._idle.length) {\n        this._idle.slice().map((item) => {\n          this._remove(item.client)\n        })\n      }\n      if (!this._clients.length) {\n        this.ended = true\n        this._endCallback()\n      }\n      return\n    }\n\n    // if we don't have any waiting, do nothing\n    if (!this._pendingQueue.length) {\n      this.log('no queued requests')\n      return\n    }\n    // if we don't have any idle clients and we have no more room do nothing\n    if (!this._idle.length && this._isFull()) {\n      return\n    }\n    const pendingItem = this._pendingQueue.shift()\n    if (this._idle.length) {\n      const idleItem = this._idle.pop()\n      clearTimeout(idleItem.timeoutId)\n      const client = idleItem.client\n      client.ref && client.ref()\n      const idleListener = idleItem.idleListener\n\n      return this._acquireClient(client, pendingItem, idleListener, false)\n    }\n    if (!this._isFull()) {\n      return this.newClient(pendingItem)\n    }\n    throw new Error('unexpected condition')\n  }\n\n  _remove(client, callback) {\n    const removed = removeWhere(this._idle, (item) => item.client === client)\n\n    if (removed !== undefined) {\n      clearTimeout(removed.timeoutId)\n    }\n\n    this._clients = this._clients.filter((c) => c !== client)\n    const context = this\n    client.end(() => {\n      context.emit('remove', client)\n\n      if (typeof callback === 'function') {\n        callback()\n      }\n    })\n  }\n\n  connect(cb) {\n    if (this.ending) {\n      const err = new Error('Cannot use a pool after calling end on the pool')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n\n    const response = promisify(this.Promise, cb)\n    const result = response.result\n\n    // if we don't have to connect a new client, don't do so\n    if (this._isFull() || this._idle.length) {\n      // if we have idle clients schedule a pulse immediately\n      if (this._idle.length) {\n        process.nextTick(() => this._pulseQueue())\n      }\n\n      if (!this.options.connectionTimeoutMillis) {\n        this._pendingQueue.push(new PendingItem(response.callback))\n        return result\n      }\n\n      const queueCallback = (err, res, done) => {\n        clearTimeout(tid)\n        response.callback(err, res, done)\n      }\n\n      const pendingItem = new PendingItem(queueCallback)\n\n      // set connection timeout on checking out an existing client\n      const tid = setTimeout(() => {\n        // remove the callback from pending waiters because\n        // we're going to call it with a timeout error\n        removeWhere(this._pendingQueue, (i) => i.callback === queueCallback)\n        pendingItem.timedOut = true\n        response.callback(new Error('timeout exceeded when trying to connect'))\n      }, this.options.connectionTimeoutMillis)\n\n      if (tid.unref) {\n        tid.unref()\n      }\n\n      this._pendingQueue.push(pendingItem)\n      return result\n    }\n\n    this.newClient(new PendingItem(response.callback))\n\n    return result\n  }\n\n  newClient(pendingItem) {\n    const client = new this.Client(this.options)\n    this._clients.push(client)\n    const idleListener = makeIdleListener(this, client)\n\n    this.log('checking client timeout')\n\n    // connection timeout logic\n    let tid\n    let timeoutHit = false\n    if (this.options.connectionTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('ending client due to timeout')\n        timeoutHit = true\n        // force kill the node driver, and let libpq do its teardown\n        client.connection ? client.connection.stream.destroy() : client.end()\n      }, this.options.connectionTimeoutMillis)\n    }\n\n    this.log('connecting new client')\n    client.connect((err) => {\n      if (tid) {\n        clearTimeout(tid)\n      }\n      client.on('error', idleListener)\n      if (err) {\n        this.log('client failed to connect', err)\n        // remove the dead client from our list of clients\n        this._clients = this._clients.filter((c) => c !== client)\n        if (timeoutHit) {\n          err = new Error('Connection terminated due to connection timeout', { cause: err })\n        }\n\n        // this client wonâ€™t be released, so move on immediately\n        this._pulseQueue()\n\n        if (!pendingItem.timedOut) {\n          pendingItem.callback(err, undefined, NOOP)\n        }\n      } else {\n        this.log('new client connected')\n\n        if (this.options.maxLifetimeSeconds !== 0) {\n          const maxLifetimeTimeout = setTimeout(() => {\n            this.log('ending client due to expired lifetime')\n            this._expired.add(client)\n            const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client)\n            if (idleIndex !== -1) {\n              this._acquireClient(\n                client,\n                new PendingItem((err, client, clientRelease) => clientRelease()),\n                idleListener,\n                false\n              )\n            }\n          }, this.options.maxLifetimeSeconds * 1000)\n\n          maxLifetimeTimeout.unref()\n          client.once('end', () => clearTimeout(maxLifetimeTimeout))\n        }\n\n        return this._acquireClient(client, pendingItem, idleListener, true)\n      }\n    })\n  }\n\n  // acquire a client for a pending work item\n  _acquireClient(client, pendingItem, idleListener, isNew) {\n    if (isNew) {\n      this.emit('connect', client)\n    }\n\n    this.emit('acquire', client)\n\n    client.release = this._releaseOnce(client, idleListener)\n\n    client.removeListener('error', idleListener)\n\n    if (!pendingItem.timedOut) {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, (err) => {\n          if (err) {\n            client.release(err)\n            return pendingItem.callback(err, undefined, NOOP)\n          }\n\n          pendingItem.callback(undefined, client, client.release)\n        })\n      } else {\n        pendingItem.callback(undefined, client, client.release)\n      }\n    } else {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, client.release)\n      } else {\n        client.release()\n      }\n    }\n  }\n\n  // returns a function that wraps _release and throws if called more than once\n  _releaseOnce(client, idleListener) {\n    let released = false\n\n    return (err) => {\n      if (released) {\n        throwOnDoubleRelease()\n      }\n\n      released = true\n      this._release(client, idleListener, err)\n    }\n  }\n\n  // release a client back to the poll, include an error\n  // to remove it from the pool\n  _release(client, idleListener, err) {\n    client.on('error', idleListener)\n\n    client._poolUseCount = (client._poolUseCount || 0) + 1\n\n    this.emit('release', err, client)\n\n    // TODO(bmc): expose a proper, public interface _queryable and _ending\n    if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n      if (client._poolUseCount >= this.options.maxUses) {\n        this.log('remove expended client')\n      }\n\n      return this._remove(client, this._pulseQueue.bind(this))\n    }\n\n    const isExpired = this._expired.has(client)\n    if (isExpired) {\n      this.log('remove expired client')\n      this._expired.delete(client)\n      return this._remove(client, this._pulseQueue.bind(this))\n    }\n\n    // idle timeout\n    let tid\n    if (this.options.idleTimeoutMillis && this._isAboveMin()) {\n      tid = setTimeout(() => {\n        if (this._isAboveMin()) {\n          this.log('remove idle client')\n          this._remove(client, this._pulseQueue.bind(this))\n        }\n      }, this.options.idleTimeoutMillis)\n\n      if (this.options.allowExitOnIdle) {\n        // allow Node to exit if this is all that's left\n        tid.unref()\n      }\n    }\n\n    if (this.options.allowExitOnIdle) {\n      client.unref()\n    }\n\n    this._idle.push(new IdleItem(client, idleListener, tid))\n    this._pulseQueue()\n  }\n\n  query(text, values, cb) {\n    // guard clause against passing a function as the first parameter\n    if (typeof text === 'function') {\n      const response = promisify(this.Promise, text)\n      setImmediate(function () {\n        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'))\n      })\n      return response.result\n    }\n\n    // allow plain text query without values\n    if (typeof values === 'function') {\n      cb = values\n      values = undefined\n    }\n    const response = promisify(this.Promise, cb)\n    cb = response.callback\n\n    this.connect((err, client) => {\n      if (err) {\n        return cb(err)\n      }\n\n      let clientReleased = false\n      const onError = (err) => {\n        if (clientReleased) {\n          return\n        }\n        clientReleased = true\n        client.release(err)\n        cb(err)\n      }\n\n      client.once('error', onError)\n      this.log('dispatching query')\n      try {\n        client.query(text, values, (err, res) => {\n          this.log('query dispatched')\n          client.removeListener('error', onError)\n          if (clientReleased) {\n            return\n          }\n          clientReleased = true\n          client.release(err)\n          if (err) {\n            return cb(err)\n          }\n          return cb(undefined, res)\n        })\n      } catch (err) {\n        client.release(err)\n        return cb(err)\n      }\n    })\n    return response.result\n  }\n\n  end(cb) {\n    this.log('ending')\n    if (this.ending) {\n      const err = new Error('Called end on pool more than once')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n    this.ending = true\n    const promised = promisify(this.Promise, cb)\n    this._endCallback = promised.callback\n    this._pulseQueue()\n    return promised.result\n  }\n\n  get waitingCount() {\n    return this._pendingQueue.length\n  }\n\n  get idleCount() {\n    return this._idle.length\n  }\n\n  get expiredCount() {\n    return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0)\n  }\n\n  get totalCount() {\n    return this._clients.length\n  }\n}\nmodule.exports = Pool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcGctcG9vbEAzLjExLjBfcGdAOC4xOC4wL25vZGVfbW9kdWxlcy9wZy1wb29sL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1oscUJBQXFCLDBEQUE4Qjs7QUFFbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwyR0FBb0I7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsWUFBWTtBQUMzRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RlZXAtYXJjaGl0ZWN0dXJlLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3BnLXBvb2xAMy4xMS4wX3BnQDguMTguMC9ub2RlX21vZHVsZXMvcGctcG9vbC9pbmRleC5qcz84YmY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5cbmNvbnN0IE5PT1AgPSBmdW5jdGlvbiAoKSB7fVxuXG5jb25zdCByZW1vdmVXaGVyZSA9IChsaXN0LCBwcmVkaWNhdGUpID0+IHtcbiAgY29uc3QgaSA9IGxpc3QuZmluZEluZGV4KHByZWRpY2F0ZSlcblxuICByZXR1cm4gaSA9PT0gLTEgPyB1bmRlZmluZWQgOiBsaXN0LnNwbGljZShpLCAxKVswXVxufVxuXG5jbGFzcyBJZGxlSXRlbSB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaWRsZUxpc3RlbmVyLCB0aW1lb3V0SWQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICAgIHRoaXMuaWRsZUxpc3RlbmVyID0gaWRsZUxpc3RlbmVyXG4gICAgdGhpcy50aW1lb3V0SWQgPSB0aW1lb3V0SWRcbiAgfVxufVxuXG5jbGFzcyBQZW5kaW5nSXRlbSB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gIH1cbn1cblxuZnVuY3Rpb24gdGhyb3dPbkRvdWJsZVJlbGVhc2UoKSB7XG4gIHRocm93IG5ldyBFcnJvcignUmVsZWFzZSBjYWxsZWQgb24gY2xpZW50IHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gcmVsZWFzZWQgdG8gdGhlIHBvb2wuJylcbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZ5KFByb21pc2UsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHJldHVybiB7IGNhbGxiYWNrOiBjYWxsYmFjaywgcmVzdWx0OiB1bmRlZmluZWQgfVxuICB9XG4gIGxldCByZWpcbiAgbGV0IHJlc1xuICBjb25zdCBjYiA9IGZ1bmN0aW9uIChlcnIsIGNsaWVudCkge1xuICAgIGVyciA/IHJlaihlcnIpIDogcmVzKGNsaWVudClcbiAgfVxuICBjb25zdCByZXN1bHQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVzID0gcmVzb2x2ZVxuICAgIHJlaiA9IHJlamVjdFxuICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgLy8gcmVwbGFjZSB0aGUgc3RhY2sgdHJhY2UgdGhhdCBsZWFkcyB0byBgVENQLm9uU3RyZWFtUmVhZGAgd2l0aCBvbmUgdGhhdCBsZWFkcyBiYWNrIHRvIHRoZVxuICAgIC8vIGFwcGxpY2F0aW9uIHRoYXQgY3JlYXRlZCB0aGUgcXVlcnlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIpXG4gICAgdGhyb3cgZXJyXG4gIH0pXG4gIHJldHVybiB7IGNhbGxiYWNrOiBjYiwgcmVzdWx0OiByZXN1bHQgfVxufVxuXG5mdW5jdGlvbiBtYWtlSWRsZUxpc3RlbmVyKHBvb2wsIGNsaWVudCkge1xuICByZXR1cm4gZnVuY3Rpb24gaWRsZUxpc3RlbmVyKGVycikge1xuICAgIGVyci5jbGllbnQgPSBjbGllbnRcblxuICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBpZGxlTGlzdGVuZXIpXG4gICAgY2xpZW50Lm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgIHBvb2wubG9nKCdhZGRpdGlvbmFsIGNsaWVudCBlcnJvciBhZnRlciBkaXNjb25uZWN0aW9uIGR1ZSB0byBlcnJvcicsIGVycilcbiAgICB9KVxuICAgIHBvb2wuX3JlbW92ZShjbGllbnQpXG4gICAgLy8gVE9ETyAtIGRvY3VtZW50IHRoYXQgb25jZSB0aGUgcG9vbCBlbWl0cyBhbiBlcnJvclxuICAgIC8vIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgJiBwdXJnZWQgYW5kIGlzIHVudXNhYmxlXG4gICAgcG9vbC5lbWl0KCdlcnJvcicsIGVyciwgY2xpZW50KVxuICB9XG59XG5cbmNsYXNzIFBvb2wgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBDbGllbnQpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucylcblxuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgJ3Bhc3N3b3JkJyBpbiBvcHRpb25zKSB7XG4gICAgICAvLyBcImhpZGluZ1wiIHRoZSBwYXNzd29yZCBzbyBpdCBkb2Vzbid0IHNob3cgdXAgaW4gc3RhY2sgdHJhY2VzXG4gICAgICAvLyBvciBpZiB0aGUgY2xpZW50IGlzIGNvbnNvbGUubG9nZ2VkXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5vcHRpb25zLCAncGFzc3dvcmQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogb3B0aW9ucy5wYXNzd29yZCxcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5zc2wgJiYgb3B0aW9ucy5zc2wua2V5KSB7XG4gICAgICAvLyBcImhpZGluZ1wiIHRoZSBzc2wtPmtleSBzbyBpdCBkb2Vzbid0IHNob3cgdXAgaW4gc3RhY2sgdHJhY2VzXG4gICAgICAvLyBvciBpZiB0aGUgY2xpZW50IGlzIGNvbnNvbGUubG9nZ2VkXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5vcHRpb25zLnNzbCwgJ2tleScsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy5tYXggPSB0aGlzLm9wdGlvbnMubWF4IHx8IHRoaXMub3B0aW9ucy5wb29sU2l6ZSB8fCAxMFxuICAgIHRoaXMub3B0aW9ucy5taW4gPSB0aGlzLm9wdGlvbnMubWluIHx8IDBcbiAgICB0aGlzLm9wdGlvbnMubWF4VXNlcyA9IHRoaXMub3B0aW9ucy5tYXhVc2VzIHx8IEluZmluaXR5XG4gICAgdGhpcy5vcHRpb25zLmFsbG93RXhpdE9uSWRsZSA9IHRoaXMub3B0aW9ucy5hbGxvd0V4aXRPbklkbGUgfHwgZmFsc2VcbiAgICB0aGlzLm9wdGlvbnMubWF4TGlmZXRpbWVTZWNvbmRzID0gdGhpcy5vcHRpb25zLm1heExpZmV0aW1lU2Vjb25kcyB8fCAwXG4gICAgdGhpcy5sb2cgPSB0aGlzLm9wdGlvbnMubG9nIHx8IGZ1bmN0aW9uICgpIHt9XG4gICAgdGhpcy5DbGllbnQgPSB0aGlzLm9wdGlvbnMuQ2xpZW50IHx8IENsaWVudCB8fCByZXF1aXJlKCdwZycpLkNsaWVudFxuICAgIHRoaXMuUHJvbWlzZSA9IHRoaXMub3B0aW9ucy5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlXG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pZGxlVGltZW91dE1pbGxpcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5pZGxlVGltZW91dE1pbGxpcyA9IDEwMDAwXG4gICAgfVxuXG4gICAgdGhpcy5fY2xpZW50cyA9IFtdXG4gICAgdGhpcy5faWRsZSA9IFtdXG4gICAgdGhpcy5fZXhwaXJlZCA9IG5ldyBXZWFrU2V0KClcbiAgICB0aGlzLl9wZW5kaW5nUXVldWUgPSBbXVxuICAgIHRoaXMuX2VuZENhbGxiYWNrID0gdW5kZWZpbmVkXG4gICAgdGhpcy5lbmRpbmcgPSBmYWxzZVxuICAgIHRoaXMuZW5kZWQgPSBmYWxzZVxuICB9XG5cbiAgX2lzRnVsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50cy5sZW5ndGggPj0gdGhpcy5vcHRpb25zLm1heFxuICB9XG5cbiAgX2lzQWJvdmVNaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudHMubGVuZ3RoID4gdGhpcy5vcHRpb25zLm1pblxuICB9XG5cbiAgX3B1bHNlUXVldWUoKSB7XG4gICAgdGhpcy5sb2coJ3B1bHNlIHF1ZXVlJylcbiAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgdGhpcy5sb2coJ3B1bHNlIHF1ZXVlIGVuZGVkJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodGhpcy5lbmRpbmcpIHtcbiAgICAgIHRoaXMubG9nKCdwdWxzZSBxdWV1ZSBvbiBlbmRpbmcnKVxuICAgICAgaWYgKHRoaXMuX2lkbGUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2lkbGUuc2xpY2UoKS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmUoaXRlbS5jbGllbnQpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2NsaWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlXG4gICAgICAgIHRoaXMuX2VuZENhbGxiYWNrKClcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYW55IHdhaXRpbmcsIGRvIG5vdGhpbmdcbiAgICBpZiAoIXRoaXMuX3BlbmRpbmdRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMubG9nKCdubyBxdWV1ZWQgcmVxdWVzdHMnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYW55IGlkbGUgY2xpZW50cyBhbmQgd2UgaGF2ZSBubyBtb3JlIHJvb20gZG8gbm90aGluZ1xuICAgIGlmICghdGhpcy5faWRsZS5sZW5ndGggJiYgdGhpcy5faXNGdWxsKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nSXRlbSA9IHRoaXMuX3BlbmRpbmdRdWV1ZS5zaGlmdCgpXG4gICAgaWYgKHRoaXMuX2lkbGUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBpZGxlSXRlbSA9IHRoaXMuX2lkbGUucG9wKClcbiAgICAgIGNsZWFyVGltZW91dChpZGxlSXRlbS50aW1lb3V0SWQpXG4gICAgICBjb25zdCBjbGllbnQgPSBpZGxlSXRlbS5jbGllbnRcbiAgICAgIGNsaWVudC5yZWYgJiYgY2xpZW50LnJlZigpXG4gICAgICBjb25zdCBpZGxlTGlzdGVuZXIgPSBpZGxlSXRlbS5pZGxlTGlzdGVuZXJcblxuICAgICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVDbGllbnQoY2xpZW50LCBwZW5kaW5nSXRlbSwgaWRsZUxpc3RlbmVyLCBmYWxzZSlcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9pc0Z1bGwoKSkge1xuICAgICAgcmV0dXJuIHRoaXMubmV3Q2xpZW50KHBlbmRpbmdJdGVtKVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgY29uZGl0aW9uJylcbiAgfVxuXG4gIF9yZW1vdmUoY2xpZW50LCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHJlbW92ZWQgPSByZW1vdmVXaGVyZSh0aGlzLl9pZGxlLCAoaXRlbSkgPT4gaXRlbS5jbGllbnQgPT09IGNsaWVudClcblxuICAgIGlmIChyZW1vdmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChyZW1vdmVkLnRpbWVvdXRJZClcbiAgICB9XG5cbiAgICB0aGlzLl9jbGllbnRzID0gdGhpcy5fY2xpZW50cy5maWx0ZXIoKGMpID0+IGMgIT09IGNsaWVudClcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpc1xuICAgIGNsaWVudC5lbmQoKCkgPT4ge1xuICAgICAgY29udGV4dC5lbWl0KCdyZW1vdmUnLCBjbGllbnQpXG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjb25uZWN0KGNiKSB7XG4gICAgaWYgKHRoaXMuZW5kaW5nKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgYSBwb29sIGFmdGVyIGNhbGxpbmcgZW5kIG9uIHRoZSBwb29sJylcbiAgICAgIHJldHVybiBjYiA/IGNiKGVycikgOiB0aGlzLlByb21pc2UucmVqZWN0KGVycilcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IHByb21pc2lmeSh0aGlzLlByb21pc2UsIGNiKVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlc3BvbnNlLnJlc3VsdFxuXG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSB0byBjb25uZWN0IGEgbmV3IGNsaWVudCwgZG9uJ3QgZG8gc29cbiAgICBpZiAodGhpcy5faXNGdWxsKCkgfHwgdGhpcy5faWRsZS5sZW5ndGgpIHtcbiAgICAgIC8vIGlmIHdlIGhhdmUgaWRsZSBjbGllbnRzIHNjaGVkdWxlIGEgcHVsc2UgaW1tZWRpYXRlbHlcbiAgICAgIGlmICh0aGlzLl9pZGxlLmxlbmd0aCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHRoaXMuX3B1bHNlUXVldWUoKSlcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY29ubmVjdGlvblRpbWVvdXRNaWxsaXMpIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1F1ZXVlLnB1c2gobmV3IFBlbmRpbmdJdGVtKHJlc3BvbnNlLmNhbGxiYWNrKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuXG4gICAgICBjb25zdCBxdWV1ZUNhbGxiYWNrID0gKGVyciwgcmVzLCBkb25lKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aWQpXG4gICAgICAgIHJlc3BvbnNlLmNhbGxiYWNrKGVyciwgcmVzLCBkb25lKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwZW5kaW5nSXRlbSA9IG5ldyBQZW5kaW5nSXRlbShxdWV1ZUNhbGxiYWNrKVxuXG4gICAgICAvLyBzZXQgY29ubmVjdGlvbiB0aW1lb3V0IG9uIGNoZWNraW5nIG91dCBhbiBleGlzdGluZyBjbGllbnRcbiAgICAgIGNvbnN0IHRpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gcGVuZGluZyB3YWl0ZXJzIGJlY2F1c2VcbiAgICAgICAgLy8gd2UncmUgZ29pbmcgdG8gY2FsbCBpdCB3aXRoIGEgdGltZW91dCBlcnJvclxuICAgICAgICByZW1vdmVXaGVyZSh0aGlzLl9wZW5kaW5nUXVldWUsIChpKSA9PiBpLmNhbGxiYWNrID09PSBxdWV1ZUNhbGxiYWNrKVxuICAgICAgICBwZW5kaW5nSXRlbS50aW1lZE91dCA9IHRydWVcbiAgICAgICAgcmVzcG9uc2UuY2FsbGJhY2sobmV3IEVycm9yKCd0aW1lb3V0IGV4Y2VlZGVkIHdoZW4gdHJ5aW5nIHRvIGNvbm5lY3QnKSlcbiAgICAgIH0sIHRoaXMub3B0aW9ucy5jb25uZWN0aW9uVGltZW91dE1pbGxpcylcblxuICAgICAgaWYgKHRpZC51bnJlZikge1xuICAgICAgICB0aWQudW5yZWYoKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wZW5kaW5nUXVldWUucHVzaChwZW5kaW5nSXRlbSlcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICB0aGlzLm5ld0NsaWVudChuZXcgUGVuZGluZ0l0ZW0ocmVzcG9uc2UuY2FsbGJhY2spKVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgbmV3Q2xpZW50KHBlbmRpbmdJdGVtKSB7XG4gICAgY29uc3QgY2xpZW50ID0gbmV3IHRoaXMuQ2xpZW50KHRoaXMub3B0aW9ucylcbiAgICB0aGlzLl9jbGllbnRzLnB1c2goY2xpZW50KVxuICAgIGNvbnN0IGlkbGVMaXN0ZW5lciA9IG1ha2VJZGxlTGlzdGVuZXIodGhpcywgY2xpZW50KVxuXG4gICAgdGhpcy5sb2coJ2NoZWNraW5nIGNsaWVudCB0aW1lb3V0JylcblxuICAgIC8vIGNvbm5lY3Rpb24gdGltZW91dCBsb2dpY1xuICAgIGxldCB0aWRcbiAgICBsZXQgdGltZW91dEhpdCA9IGZhbHNlXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25uZWN0aW9uVGltZW91dE1pbGxpcykge1xuICAgICAgdGlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKCdlbmRpbmcgY2xpZW50IGR1ZSB0byB0aW1lb3V0JylcbiAgICAgICAgdGltZW91dEhpdCA9IHRydWVcbiAgICAgICAgLy8gZm9yY2Uga2lsbCB0aGUgbm9kZSBkcml2ZXIsIGFuZCBsZXQgbGlicHEgZG8gaXRzIHRlYXJkb3duXG4gICAgICAgIGNsaWVudC5jb25uZWN0aW9uID8gY2xpZW50LmNvbm5lY3Rpb24uc3RyZWFtLmRlc3Ryb3koKSA6IGNsaWVudC5lbmQoKVxuICAgICAgfSwgdGhpcy5vcHRpb25zLmNvbm5lY3Rpb25UaW1lb3V0TWlsbGlzKVxuICAgIH1cblxuICAgIHRoaXMubG9nKCdjb25uZWN0aW5nIG5ldyBjbGllbnQnKVxuICAgIGNsaWVudC5jb25uZWN0KChlcnIpID0+IHtcbiAgICAgIGlmICh0aWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpZClcbiAgICAgIH1cbiAgICAgIGNsaWVudC5vbignZXJyb3InLCBpZGxlTGlzdGVuZXIpXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMubG9nKCdjbGllbnQgZmFpbGVkIHRvIGNvbm5lY3QnLCBlcnIpXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZGVhZCBjbGllbnQgZnJvbSBvdXIgbGlzdCBvZiBjbGllbnRzXG4gICAgICAgIHRoaXMuX2NsaWVudHMgPSB0aGlzLl9jbGllbnRzLmZpbHRlcigoYykgPT4gYyAhPT0gY2xpZW50KVxuICAgICAgICBpZiAodGltZW91dEhpdCkge1xuICAgICAgICAgIGVyciA9IG5ldyBFcnJvcignQ29ubmVjdGlvbiB0ZXJtaW5hdGVkIGR1ZSB0byBjb25uZWN0aW9uIHRpbWVvdXQnLCB7IGNhdXNlOiBlcnIgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMgY2xpZW50IHdvbuKAmXQgYmUgcmVsZWFzZWQsIHNvIG1vdmUgb24gaW1tZWRpYXRlbHlcbiAgICAgICAgdGhpcy5fcHVsc2VRdWV1ZSgpXG5cbiAgICAgICAgaWYgKCFwZW5kaW5nSXRlbS50aW1lZE91dCkge1xuICAgICAgICAgIHBlbmRpbmdJdGVtLmNhbGxiYWNrKGVyciwgdW5kZWZpbmVkLCBOT09QKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZygnbmV3IGNsaWVudCBjb25uZWN0ZWQnKVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4TGlmZXRpbWVTZWNvbmRzICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgbWF4TGlmZXRpbWVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZygnZW5kaW5nIGNsaWVudCBkdWUgdG8gZXhwaXJlZCBsaWZldGltZScpXG4gICAgICAgICAgICB0aGlzLl9leHBpcmVkLmFkZChjbGllbnQpXG4gICAgICAgICAgICBjb25zdCBpZGxlSW5kZXggPSB0aGlzLl9pZGxlLmZpbmRJbmRleCgoaWRsZUl0ZW0pID0+IGlkbGVJdGVtLmNsaWVudCA9PT0gY2xpZW50KVxuICAgICAgICAgICAgaWYgKGlkbGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWNxdWlyZUNsaWVudChcbiAgICAgICAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgICAgICAgbmV3IFBlbmRpbmdJdGVtKChlcnIsIGNsaWVudCwgY2xpZW50UmVsZWFzZSkgPT4gY2xpZW50UmVsZWFzZSgpKSxcbiAgICAgICAgICAgICAgICBpZGxlTGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy5tYXhMaWZldGltZVNlY29uZHMgKiAxMDAwKVxuXG4gICAgICAgICAgbWF4TGlmZXRpbWVUaW1lb3V0LnVucmVmKClcbiAgICAgICAgICBjbGllbnQub25jZSgnZW5kJywgKCkgPT4gY2xlYXJUaW1lb3V0KG1heExpZmV0aW1lVGltZW91dCkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUNsaWVudChjbGllbnQsIHBlbmRpbmdJdGVtLCBpZGxlTGlzdGVuZXIsIHRydWUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIGFjcXVpcmUgYSBjbGllbnQgZm9yIGEgcGVuZGluZyB3b3JrIGl0ZW1cbiAgX2FjcXVpcmVDbGllbnQoY2xpZW50LCBwZW5kaW5nSXRlbSwgaWRsZUxpc3RlbmVyLCBpc05ldykge1xuICAgIGlmIChpc05ldykge1xuICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JywgY2xpZW50KVxuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnYWNxdWlyZScsIGNsaWVudClcblxuICAgIGNsaWVudC5yZWxlYXNlID0gdGhpcy5fcmVsZWFzZU9uY2UoY2xpZW50LCBpZGxlTGlzdGVuZXIpXG5cbiAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgaWRsZUxpc3RlbmVyKVxuXG4gICAgaWYgKCFwZW5kaW5nSXRlbS50aW1lZE91dCkge1xuICAgICAgaWYgKGlzTmV3ICYmIHRoaXMub3B0aW9ucy52ZXJpZnkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeShjbGllbnQsIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjbGllbnQucmVsZWFzZShlcnIpXG4gICAgICAgICAgICByZXR1cm4gcGVuZGluZ0l0ZW0uY2FsbGJhY2soZXJyLCB1bmRlZmluZWQsIE5PT1ApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGVuZGluZ0l0ZW0uY2FsbGJhY2sodW5kZWZpbmVkLCBjbGllbnQsIGNsaWVudC5yZWxlYXNlKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVuZGluZ0l0ZW0uY2FsbGJhY2sodW5kZWZpbmVkLCBjbGllbnQsIGNsaWVudC5yZWxlYXNlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNOZXcgJiYgdGhpcy5vcHRpb25zLnZlcmlmeSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5KGNsaWVudCwgY2xpZW50LnJlbGVhc2UpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGllbnQucmVsZWFzZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgX3JlbGVhc2UgYW5kIHRocm93cyBpZiBjYWxsZWQgbW9yZSB0aGFuIG9uY2VcbiAgX3JlbGVhc2VPbmNlKGNsaWVudCwgaWRsZUxpc3RlbmVyKSB7XG4gICAgbGV0IHJlbGVhc2VkID0gZmFsc2VcblxuICAgIHJldHVybiAoZXJyKSA9PiB7XG4gICAgICBpZiAocmVsZWFzZWQpIHtcbiAgICAgICAgdGhyb3dPbkRvdWJsZVJlbGVhc2UoKVxuICAgICAgfVxuXG4gICAgICByZWxlYXNlZCA9IHRydWVcbiAgICAgIHRoaXMuX3JlbGVhc2UoY2xpZW50LCBpZGxlTGlzdGVuZXIsIGVycilcbiAgICB9XG4gIH1cblxuICAvLyByZWxlYXNlIGEgY2xpZW50IGJhY2sgdG8gdGhlIHBvbGwsIGluY2x1ZGUgYW4gZXJyb3JcbiAgLy8gdG8gcmVtb3ZlIGl0IGZyb20gdGhlIHBvb2xcbiAgX3JlbGVhc2UoY2xpZW50LCBpZGxlTGlzdGVuZXIsIGVycikge1xuICAgIGNsaWVudC5vbignZXJyb3InLCBpZGxlTGlzdGVuZXIpXG5cbiAgICBjbGllbnQuX3Bvb2xVc2VDb3VudCA9IChjbGllbnQuX3Bvb2xVc2VDb3VudCB8fCAwKSArIDFcblxuICAgIHRoaXMuZW1pdCgncmVsZWFzZScsIGVyciwgY2xpZW50KVxuXG4gICAgLy8gVE9ETyhibWMpOiBleHBvc2UgYSBwcm9wZXIsIHB1YmxpYyBpbnRlcmZhY2UgX3F1ZXJ5YWJsZSBhbmQgX2VuZGluZ1xuICAgIGlmIChlcnIgfHwgdGhpcy5lbmRpbmcgfHwgIWNsaWVudC5fcXVlcnlhYmxlIHx8IGNsaWVudC5fZW5kaW5nIHx8IGNsaWVudC5fcG9vbFVzZUNvdW50ID49IHRoaXMub3B0aW9ucy5tYXhVc2VzKSB7XG4gICAgICBpZiAoY2xpZW50Ll9wb29sVXNlQ291bnQgPj0gdGhpcy5vcHRpb25zLm1heFVzZXMpIHtcbiAgICAgICAgdGhpcy5sb2coJ3JlbW92ZSBleHBlbmRlZCBjbGllbnQnKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlKGNsaWVudCwgdGhpcy5fcHVsc2VRdWV1ZS5iaW5kKHRoaXMpKVxuICAgIH1cblxuICAgIGNvbnN0IGlzRXhwaXJlZCA9IHRoaXMuX2V4cGlyZWQuaGFzKGNsaWVudClcbiAgICBpZiAoaXNFeHBpcmVkKSB7XG4gICAgICB0aGlzLmxvZygncmVtb3ZlIGV4cGlyZWQgY2xpZW50JylcbiAgICAgIHRoaXMuX2V4cGlyZWQuZGVsZXRlKGNsaWVudClcbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdmUoY2xpZW50LCB0aGlzLl9wdWxzZVF1ZXVlLmJpbmQodGhpcykpXG4gICAgfVxuXG4gICAgLy8gaWRsZSB0aW1lb3V0XG4gICAgbGV0IHRpZFxuICAgIGlmICh0aGlzLm9wdGlvbnMuaWRsZVRpbWVvdXRNaWxsaXMgJiYgdGhpcy5faXNBYm92ZU1pbigpKSB7XG4gICAgICB0aWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQWJvdmVNaW4oKSkge1xuICAgICAgICAgIHRoaXMubG9nKCdyZW1vdmUgaWRsZSBjbGllbnQnKVxuICAgICAgICAgIHRoaXMuX3JlbW92ZShjbGllbnQsIHRoaXMuX3B1bHNlUXVldWUuYmluZCh0aGlzKSlcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5vcHRpb25zLmlkbGVUaW1lb3V0TWlsbGlzKVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93RXhpdE9uSWRsZSkge1xuICAgICAgICAvLyBhbGxvdyBOb2RlIHRvIGV4aXQgaWYgdGhpcyBpcyBhbGwgdGhhdCdzIGxlZnRcbiAgICAgICAgdGlkLnVucmVmKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93RXhpdE9uSWRsZSkge1xuICAgICAgY2xpZW50LnVucmVmKClcbiAgICB9XG5cbiAgICB0aGlzLl9pZGxlLnB1c2gobmV3IElkbGVJdGVtKGNsaWVudCwgaWRsZUxpc3RlbmVyLCB0aWQpKVxuICAgIHRoaXMuX3B1bHNlUXVldWUoKVxuICB9XG5cbiAgcXVlcnkodGV4dCwgdmFsdWVzLCBjYikge1xuICAgIC8vIGd1YXJkIGNsYXVzZSBhZ2FpbnN0IHBhc3NpbmcgYSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyXG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHByb21pc2lmeSh0aGlzLlByb21pc2UsIHRleHQpXG4gICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuY2FsbGJhY2sobmV3IEVycm9yKCdQYXNzaW5nIGEgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBwb29sLnF1ZXJ5IGlzIG5vdCBzdXBwb3J0ZWQnKSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgcGxhaW4gdGV4dCBxdWVyeSB3aXRob3V0IHZhbHVlc1xuICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IHZhbHVlc1xuICAgICAgdmFsdWVzID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gcHJvbWlzaWZ5KHRoaXMuUHJvbWlzZSwgY2IpXG4gICAgY2IgPSByZXNwb25zZS5jYWxsYmFja1xuXG4gICAgdGhpcy5jb25uZWN0KChlcnIsIGNsaWVudCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuXG4gICAgICBsZXQgY2xpZW50UmVsZWFzZWQgPSBmYWxzZVxuICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgaWYgKGNsaWVudFJlbGVhc2VkKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY2xpZW50UmVsZWFzZWQgPSB0cnVlXG4gICAgICAgIGNsaWVudC5yZWxlYXNlKGVycilcbiAgICAgICAgY2IoZXJyKVxuICAgICAgfVxuXG4gICAgICBjbGllbnQub25jZSgnZXJyb3InLCBvbkVycm9yKVxuICAgICAgdGhpcy5sb2coJ2Rpc3BhdGNoaW5nIHF1ZXJ5JylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsaWVudC5xdWVyeSh0ZXh0LCB2YWx1ZXMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgIHRoaXMubG9nKCdxdWVyeSBkaXNwYXRjaGVkJylcbiAgICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcilcbiAgICAgICAgICBpZiAoY2xpZW50UmVsZWFzZWQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBjbGllbnRSZWxlYXNlZCA9IHRydWVcbiAgICAgICAgICBjbGllbnQucmVsZWFzZShlcnIpXG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNiKHVuZGVmaW5lZCwgcmVzKVxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNsaWVudC5yZWxlYXNlKGVycilcbiAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiByZXNwb25zZS5yZXN1bHRcbiAgfVxuXG4gIGVuZChjYikge1xuICAgIHRoaXMubG9nKCdlbmRpbmcnKVxuICAgIGlmICh0aGlzLmVuZGluZykge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdDYWxsZWQgZW5kIG9uIHBvb2wgbW9yZSB0aGFuIG9uY2UnKVxuICAgICAgcmV0dXJuIGNiID8gY2IoZXJyKSA6IHRoaXMuUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgIH1cbiAgICB0aGlzLmVuZGluZyA9IHRydWVcbiAgICBjb25zdCBwcm9taXNlZCA9IHByb21pc2lmeSh0aGlzLlByb21pc2UsIGNiKVxuICAgIHRoaXMuX2VuZENhbGxiYWNrID0gcHJvbWlzZWQuY2FsbGJhY2tcbiAgICB0aGlzLl9wdWxzZVF1ZXVlKClcbiAgICByZXR1cm4gcHJvbWlzZWQucmVzdWx0XG4gIH1cblxuICBnZXQgd2FpdGluZ0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nUXVldWUubGVuZ3RoXG4gIH1cblxuICBnZXQgaWRsZUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9pZGxlLmxlbmd0aFxuICB9XG5cbiAgZ2V0IGV4cGlyZWRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50cy5yZWR1Y2UoKGFjYywgY2xpZW50KSA9PiBhY2MgKyAodGhpcy5fZXhwaXJlZC5oYXMoY2xpZW50KSA/IDEgOiAwKSwgMClcbiAgfVxuXG4gIGdldCB0b3RhbENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRzLmxlbmd0aFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/pg-pool@3.11.0_pg@8.18.0/node_modules/pg-pool/index.js\n");

/***/ })

};
;